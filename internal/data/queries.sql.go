// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package data

import (
	"context"
	"database/sql"
)

const getAllFeeds = `-- name: GetAllFeeds :many
SELECT id
FROM Feeds
`

func (q *Queries) GetAllFeeds(ctx context.Context) ([][]byte, error) {
	rows, err := q.db.QueryContext(ctx, getAllFeeds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var id []byte
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodesForFeed = `-- name: GetEpisodesForFeed :many
SELECT id,
  audio_url,
  audio_length_bytes,
  description,
  duration,
  feed_id,
  released_at,
  thumbnail,
  title,
  video_url
FROM Episodes
WHERE feed_id = ?
`

func (q *Queries) GetEpisodesForFeed(ctx context.Context, feedID string) ([]Episode, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodesForFeed, feedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Episode
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.AudioUrl,
			&i.AudioLengthBytes,
			&i.Description,
			&i.Duration,
			&i.FeedID,
			&i.ReleasedAt,
			&i.Thumbnail,
			&i.Title,
			&i.VideoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeedXML = `-- name: GetFeedXML :one
SELECT xml FROM Feeds WHERE id = ?
`

func (q *Queries) GetFeedXML(ctx context.Context, id []byte) (string, error) {
	row := q.db.QueryRowContext(ctx, getFeedXML, id)
	var xml string
	err := row.Scan(&xml)
	return xml, err
}

const getOlderEpisodesForFeed = `-- name: GetOlderEpisodesForFeed :many
SELECT id, audio_url, audio_length_bytes, description, duration, feed_id, released_at, thumbnail, title, video_url
FROM Episodes as e
WHERE e.feed_id = ?1
AND released_at < (
    SELECT released_at
    FROM Episodes AS e
    WHERE e.id = ?2
      AND e.feed_id = ?1
)
ORDER BY released_at DESC
`

type GetOlderEpisodesForFeedParams struct {
	FeedID string
	ID     []byte
}

func (q *Queries) GetOlderEpisodesForFeed(ctx context.Context, arg GetOlderEpisodesForFeedParams) ([]Episode, error) {
	rows, err := q.db.QueryContext(ctx, getOlderEpisodesForFeed, arg.FeedID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Episode
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.AudioUrl,
			&i.AudioLengthBytes,
			&i.Description,
			&i.Duration,
			&i.FeedID,
			&i.ReleasedAt,
			&i.Thumbnail,
			&i.Title,
			&i.VideoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEpisode = `-- name: UpsertEpisode :exec
INSERT OR REPLACE INTO Episodes (
    id,
    audio_url,
    audio_length_bytes,
    description,
    duration,
    feed_id,
    released_at,
    thumbnail,
    title,
    video_url
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type UpsertEpisodeParams struct {
	ID               []byte
	AudioUrl         string
	AudioLengthBytes int64
	Description      sql.NullString
	Duration         sql.NullInt64
	FeedID           string
	ReleasedAt       sql.NullTime
	Thumbnail        sql.NullString
	Title            string
	VideoUrl         sql.NullString
}

func (q *Queries) UpsertEpisode(ctx context.Context, arg UpsertEpisodeParams) error {
	_, err := q.db.ExecContext(ctx, upsertEpisode,
		arg.ID,
		arg.AudioUrl,
		arg.AudioLengthBytes,
		arg.Description,
		arg.Duration,
		arg.FeedID,
		arg.ReleasedAt,
		arg.Thumbnail,
		arg.Title,
		arg.VideoUrl,
	)
	return err
}

const upsertFeed = `-- name: UpsertFeed :exec
INSERT OR REPLACE INTO Feeds (
    id,
    created_at,
    description,
    title,
    updated_at,
    link,
    xml
) VALUES (
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    ?,
    ?
)
`

type UpsertFeedParams struct {
	ID          []byte
	CreatedAt   sql.NullTime
	Description sql.NullString
	Title       string
	Link        string
	Xml         string
}

func (q *Queries) UpsertFeed(ctx context.Context, arg UpsertFeedParams) error {
	_, err := q.db.ExecContext(ctx, upsertFeed,
		arg.ID,
		arg.CreatedAt,
		arg.Description,
		arg.Title,
		arg.Link,
		arg.Xml,
	)
	return err
}
